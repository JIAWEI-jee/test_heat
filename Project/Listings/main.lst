C51 COMPILER V9.56.0.0   MAIN                                                              11/04/2020 11:07:50 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\program_list\keil\C51\BIN\C51.EXE ..\user\main.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\hardwa
                    -re\DELAY;..\hardware\ADC;..\hardware\Flash;..\hardware\Uart;..\hardware\Key;..\hardware\Pwm;..\hardware\WDT;..\hardware\
                    -Timer;..\hardware\LCDdisplay;..\hardware\PID) DEBUG OBJECTEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\mai
                    -n.obj)

line level    source

   1          /**
   2          * ************************************************************************************
   3          * @Examle Version   K8104
   4          * @Demo Version   V1.00.00
   5          * @Date       2020.6。23
   6          * ************************************************************************************
   7          *
   8          **/
   9          
  10          #define ALLOCATE_EXTERN
  11          #include "HC89F3541.H"
  12          #include "delay.h"
  13          #include "adc.h"
  14          #include "flash.h"
  15          #include "key.h"
  16          #include "uart.h"
  17          #include "pwm.h"
  18          #include "wdt.h"
  19          #include "timer.h"
  20          #include "lcddisplay.h"
  21          #include "PID.h"
  22          
  23          #define SKU 8104
  24          #define SOFT_VER "1.01.00"
  25          
  26          
  27          u16 adc_cnt = 0;
  28          u8  first_heat_std = 0;
  29          u8  error_std = 0;
  30          
  31          void Clock ( void );
  32          void Set_Temp ( void );
  33          void Controll_Heat ( void );
  34          void Detection_Input(void);
  35          
  36          
  37          
  38          /***************************************************/
  39          /*
  40          函数名称；key_handle()
  41          函数功能：按键处理函数
  42          入口参数：null
  43          出口参数：null
  44          函数说明；处理按键返回的键值调整相应功能
  45          */
  46          /********************************************************/
  47          
  48          static void key_handle ( void )
  49          {
  50   1        u8 key_val = 0;
  51   1      
  52   1        if ( error_std == 0 )
C51 COMPILER V9.56.0.0   MAIN                                                              11/04/2020 11:07:50 PAGE 2   

  53   1      
  54   1        {
  55   2          key_val = key_scan();
  56   2        }
  57   1        else
  58   1        {
  59   2          key_val = 0;
  60   2        }
  61   1        if ( (key_val == KEY_1_PRES)&&(calibration_std == 0) )
  62   1        {
  63   2          KEY_printf ( " key_scan\r\n" );
  64   2          if ( get_device_state() == ON )
  65   2          {
  66   3            set_device_state ( OFF );
  67   3            led_set_off();
  68   3            set_pwm ( 0 );
  69   3          }
  70   2          else
  71   2          {
  72   3            set_device_state ( ON );
  73   3            set_time_sec();
  74   3            Set_Temp ( );
  75   3            //  gm_printf ( " spid.iSetVal = %d \r\n",  spid.iSetVal);
  76   3            first_heat_std = 1;
  77   3            led_set_on();
  78   3          }
  79   2        }
  80   1        else if ( get_device_state() == ON )
  81   1        {
  82   2      
  83   2         if ( key_val == LED_STAY_ON )
  84   2          {
  85   3      //      KEY_printf ( " KEY_led_PRES\r\n" );
  86   3            led_set_on();
  87   3          }
  88   2      
  89   2      
  90   2          if ( key_val == KEY_2_PRES )
  91   2          {
  92   3             led_set_on();
  93   3      //      KEY_printf ( " KEY_2_PRES\r\n" );
  94   3            if ( flash_info.gap < GAP_H )
  95   3            {
  96   4              flash_info.gap++;
  97   4      
  98   4            }
  99   3            else
 100   3            {
 101   4              flash_info.gap = GAP_1;
 102   4            }
 103   3          
 104   3      
 105   3            first_heat_std = 1;
 106   3            Set_Temp ( );
 107   3            //  gm_printf ( " spid.iSetVal = %d \r\n",  spid.iSetVal);
 108   3            lcd_display_gap ( flash_info.gap );
 109   3            //set_time_sec();
 110   3            flah_save_data();
 111   3          }
 112   2          else if ( key_val == KEY_3_PRES ) //??
 113   2          {
 114   3            led_set_on();
C51 COMPILER V9.56.0.0   MAIN                                                              11/04/2020 11:07:50 PAGE 3   

 115   3            if ( flash_info.timer < 0x05 )
 116   3            {
 117   4              flash_info.timer++;
 118   4            }
 119   3            else
 120   3            {
 121   4              flash_info.timer = TIMER_ON;
 122   4            }
 123   3            if ( flash_info.gap > GAP_1 )
 124   3            {
 125   4              if ( flash_info.timer == TIMER_ON )
 126   4              {
 127   5                On_stay = 2;
 128   5              }
 129   4              else if ( flash_info.timer > TIMER_2H )
 130   4              {
 131   5                Gap_protect_std = 2;
 132   5              }
 133   4            }
 134   3          //  KEY_printf ( "timer:%d \r\n", ( u16 ) flash_info.timer );
 135   3            lcd_display_time ( flash_info.timer );
 136   3            set_time_sec();
 137   3            flah_save_data();
 138   3          }
 139   2        }
 140   1      }
 141          
 142          
 143          u16 calibration_temperature(u16 temper)
 144          {
 145   1        u8 temp1 = 0;
 146   1        if ( (usart_rx_flag == 2)&&(calibration_std == 1))
 147   1        { 
 148   2          temp1 = (u8)temper;
 149   2          usart_rx_flag = 0;
 150   2          flash_info.correct_std = 1;
 151   2      //    hal_uart_putchar(temp1);
 152   2      //    hal_uart_putchar(temper_val);
 153   2         if (temper_val > 15) 
 154   2         { 
 155   3          if (temper_val > temp1)
 156   3          {
 157   4            flash_info.correct_value = temper_val - temp1;
 158   4            flash_info.correct_sign = 1; //为正公差
 159   4          }
 160   3          else 
 161   3          {
 162   4           flash_info.correct_value = temp1 - temper_val;
 163   4            
 164   4            hal_uart_putchar(flash_info.correct_value);
 165   4           flash_info.correct_sign = 2; //为负公差
 166   4          } 
 167   3          if ((flash_info.correct_value < 2)||(flash_info.correct_value > 20))
 168   3          {
 169   4             flash_info.correct_value = 0;
 170   4             flash_info.correct_sign = 0;
 171   4          }
 172   3          flah_save_data();
 173   3          producte_send_cmd(0x02, 0x02);
 174   3         }
 175   2        }
 176   1          if (flash_info.correct_sign == 1)
C51 COMPILER V9.56.0.0   MAIN                                                              11/04/2020 11:07:50 PAGE 4   

 177   1        {
 178   2         return ((u16) (temper = temper + flash_info.correct_value) );
 179   2        }
 180   1        else if ( flash_info.correct_sign == 2)
 181   1        {
 182   2         return ((u16) (temper = temper - flash_info.correct_value) );
 183   2        }
 184   1        return ((u16) temper );
 185   1      
 186   1      } 
 187          
 188          
 189          
 190          u16 temp_calc ( u16 uRt,u16 uRw )
 191          {
 192   1        u16 i = 0;
 193   1        u16 basi_tmp = 40;
 194   1        
 195   1        float u1 = 0;
 196   1        float u3 = 0;
 197   1        if ( uRt < 90 )
 198   1        {
 199   2          return 0xff;
 200   2        }
 201   1      
 202   1        u1 = ( float ) uRt/1000;
 203   1        u3 =  ( float ) uRw /1000;
 204   1        u1 = (  u3 - u1 ) / u1 * 750;
 205   1        if ( u1 < 0 )
 206   1        {
 207   2          return 0xff;
 208   2        }
 209   1      //  gm_printf ( "R = %f  \r\n",u1 );
 210   1      
 211   1      
 212   1        if(u1 > Temperature_Value)
 213   1          {
 214   2               i = (u1 - Temperature_Value)/0.4;
 215   2                //gm_printf("over 40  i:%d \r\n",i);
 216   2            basi_tmp = basi_tmp + i;
 217   2            }
 218   1      
 219   1        else
 220   1          {
 221   2               i = (Temperature_Value - u1)/0.4;
 222   2              //  gm_printf("under 40  i:%d \r\n",i);
 223   2            basi_tmp = basi_tmp - i;
 224   2            }
 225   1          
 226   1      //  gm_printf("basi_tmp:%d \r\n",basi_tmp);
 227   1      if (flash_info.gap == GAP_3)
 228   1            basi_tmp = basi_tmp - 5;
 229   1          
 230   1        return  basi_tmp;
 231   1      }
 232          
 233          
 234          /*********************************************************/
 235          /*
 236          函数名称；temperature_handle()
 237          函数功能：温度处理函数
 238          入口参数：null
C51 COMPILER V9.56.0.0   MAIN                                                              11/04/2020 11:07:50 PAGE 5   

 239          出口参数：null
 240          函数说明；根据ADC侦测到的值算出温度值，通过温度的值进行温度控制
 241          */
 242          /********************************************************/
 243          
 244          void temperature_handle ( void )
 245          {
 246   1        u16 temp = 0;
 247   1        u16 adc_val1 = 0,adc_val2 = 0;
 248   1      
 249   1        adc_cnt++;
 250   1      
 251   1        if ( adc_cnt >= 50000 )
 252   1        {
 253   2          adc_cnt = 0;
 254   2          get_voltage ( &adc_val1,&adc_val2 );
 255   2      
 256   2        //  KEY_printf ( "adv1 = %d adv2 =%d \r\n",adc_val1,adc_val2 );  //pjw set
 257   2          temp = temp_calc ( adc_val1, adc_val2 );
 258   2        //  KEY_printf ( "temp val:%d \r\n",temp );
 259   2            temp =  calibration_temperature(temp);
 260   2      //    KEY_printf ( "%d \r\n",temp );
 261   2      
 262   2          if (adc_val1 > 90)  //adc_val1 > 50
 263   2          {
 264   3            if ( get_device_state() == ON )
 265   3            {
 266   4              lcd_off( ON );
 267   4               if ( first_heat_std == 1 )
 268   4              {
 269   5                first_heat_std = 0;
 270   5                if ( temp > 50 )
 271   5                {
 272   6                  Heat_start_std = 0;
 273   6                  heat_step = 0;
 274   6                //  KEY_printf ( "first_heat_std heat_step = 0; \r\n" );  //pjw set
 275   6                }
 276   5                else
 277   5                {
 278   6                  Heat_start_std = 1;
 279   6                  heat_step = 1;
 280   6                //  KEY_printf ( "first_heat_std heat_step = 1; \r\n" );  //pjw set
 281   6                }
 282   5              }
 283   4      
 284   4              spid.iCurVal = temp*10;
 285   4              PID_Operation ();
 286   4              lcd_display_time ( flash_info.timer );
 287   4              lcd_display_gap ( flash_info.gap );
 288   4              Controll_Heat (  );
 289   4            }
 290   3            else
 291   3            {
 292   4                   
 293   4                    if (calibration_std == 1)
 294   4              {
 295   5                  set_pwm ( 0 );
 296   5                lcd_clear_all();
 297   5                   
 298   5                lcd_cailbration ();
 299   5              }
 300   4              else
C51 COMPILER V9.56.0.0   MAIN                                                              11/04/2020 11:07:50 PAGE 6   

 301   4              { 
 302   5            
 303   5              lcd_off( OFF );
 304   5              set_pwm ( 0 );
 305   5              lcd_clear_all();
 306   5                
 307   5              } 
 308   4                   
 309   4            }
 310   3            error_std = 0;
 311   3          }
 312   2          else
 313   2          {
 314   3      
 315   3        calibration_std = 0;
 316   3            lcd_off( Error );
 317   3            lcd_error (  );
 318   3            error_std = 1;
 319   3          }
 320   2      
 321   2      
 322   2        }
 323   1      
 324   1      
 325   1      }
 326          
 327          
 328          
 329          
 330          
 331          
 332          
 333          
 334          void main()
 335          {
 336   1        Clock();
 337   1        uart_init();
 338   1        adc_init();
 339   1        EA = 1;
 340   1        time0_init ();            //打开总中断
 341   1        key_init();
 342   1        flash_init();
 343   1        PID_Init();
 344   1        pwm_init ( 200 );
 345   1        wdt_init ( 2 );
 346   1        LCD_Init();
 347   1         led_set_on();
 348   1        lcd_display_On();
 349   1        delay_ms ( 1200 );
 350   1        lcd_display_time ( TIMER_OFF );
 351   1         lcd_display_gap ( GAP_6 );
 352   1        delay_ms ( 600 );
 353   1        led_set_off();
 354   1        lcd_clear_all ();
 355   1        Detection_Input();
 356   1        
 357   1        gm_printf ( "\r\n==================================\r\n" );
 358   1        gm_printf ( "sku:K%d \r\n", ( u16 ) SKU );
 359   1        gm_printf ( "soft version:%s \r\n",SOFT_VER );
 360   1        gm_printf ( "gap %d \r\n", ( u16 ) flash_info.gap );      //档位
 361   1        gm_printf ( "timer %d \r\n", ( u16 ) flash_info.timer );  // 定时
 362   1        gm_printf ( "Input_Voltage_std = %d\r\n" ,Input_Voltage_std); //输入电压
C51 COMPILER V9.56.0.0   MAIN                                                              11/04/2020 11:07:50 PAGE 7   

 363   1        gm_printf ( "==================================\r\n" );
 364   1      
 365   1        while ( 1 )
 366   1        {
 367   2      
 368   2      
 369   2          temperature_handle();
 370   2          key_handle ();
 371   2      
 372   2          clear_wdt();
 373   2      
 374   2        }
 375   1      }
 376          
 377          
 378          
 379          void Clock ( void )
 380          {
 381   1        /************************************系统初始化****************************************/
 382   1        CLKSWR = 0x51;            //选择内部高频RC为系统时钟，内部高频RC 2分频，Fosc=16MHz
 383   1        CLKDIV = 0x01;            //Fosc 1分频得到Fcpu，Fcpu=16MHz
 384   1      }
 385          
 386          
 387          /***************************************************/
 388          /*
 389          函数名称；Controll_Heat()
 390          函数功能：加热PWM控制
 391          入口参数：null
 392          出口参数：null
 393          函数说明；根据控制算法得到的占空比输出功率
 394          */
 395          /********************************************************/
 396          
 397          void Controll_Heat ( void )
 398          {
 399   1        //gm_printf ( " spid.iPriVal = %d \r\n",  spid.iPriVal);
 400   1        u8 heat_step_val = 100;
 401   1        if (Input_Voltage_std == V_24_status)
 402   1          {
 403   2                spid.iPriVal = spid.iPriVal/2;   
 404   2                heat_step_val = 50;
 405   2            }
 406   1        if (heat_step == 1)
 407   1          {
 408   2            set_pwm (heat_step_val);
 409   2          }
 410   1        else if (heat_step == 0)
 411   1          
 412   1          {
 413   2             set_pwm ((u8) spid.iPriVal);  //(u8) spid.iPriVal
 414   2          }
 415   1      }
 416          
 417          /***************************************************/
 418          /*
 419          函数名称；Set_Temp()
 420          函数功能：设定目标温度
 421          入口参数：null
 422          出口参数：null
 423          函数说明；根据不同档位设定要加热到的目标温度
 424          */
C51 COMPILER V9.56.0.0   MAIN                                                              11/04/2020 11:07:50 PAGE 8   

 425          /********************************************************/
 426          
 427          void Set_Temp ( void )
 428          {
 429   1      
 430   1      
 431   1        switch ( flash_info.gap )
 432   1        {
 433   2          case GAP_WARM:
 434   2      
 435   2            break;
 436   2          case GAP_1:
 437   2            spid.iSetVal = GAP_1_temp*10;
 438   2            break;
 439   2          case GAP_2:
 440   2            spid.iSetVal = GAP_2_temp*10;
 441   2            break;
 442   2          case GAP_3:
 443   2            spid.iSetVal = GAP_3_temp*10;
 444   2            break;
 445   2          case GAP_H:
 446   2            spid.iSetVal = GAP_4_temp*10;
 447   2            break;
 448   2        }
 449   1      }
 450          
 451          /*********************************************************/
 452          /*
 453          函数名称；Protect()
 454          函数功能：PID运算
 455          入口参数：null
 456          出口参数：null
 457          函数说明；大于Gap1档位情况下加热超过2小时会跳到Gap1
 458          */
 459          /********************************************************/
 460          //void Protect ( void )
 461          //{
 462          //  if ( over_rang_time_std == 1 )
 463          //  {
 464          //    if ( flash_info.gap > GAP_1 )
 465          //    {
 466          //      flash_info.gap = GAP_1;
 467          //      Set_Temp ( );
 468          //      flah_save_data();
 469          //      over_rang_time_std = 0;
 470          //    }
 471          //  }
 472          //}
 473          
 474          
 475          void Detection_Input(void)
 476          {
 477   1        u16 input = 0;
 478   1       input = Detection_Input_Voltage( );
 479   1       if (input > 1600)
 480   1        {
 481   2        //gm_printf ( "input24 = %d\r\n" ,input); //输入电压
 482   2        Input_Voltage_std = V_24_status;
 483   2        }
 484   1       else 
 485   1        {
 486   2        //gm_printf ( "input12 = %d\r\n" ,input); //输入电压
C51 COMPILER V9.56.0.0   MAIN                                                              11/04/2020 11:07:50 PAGE 9   

 487   2        Input_Voltage_std = V_12_status;
 488   2        }
 489   1      }
 490          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1465    ----
   CONSTANT SIZE    =    173    ----
   XDATA SIZE       =      4      23
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
