C51 COMPILER V9.56.0.0   ADC                                                               09/23/2020 14:29:51 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN .\Objects\adc.obj
COMPILER INVOKED BY: C:\program_list\keil\C51\BIN\C51.EXE ..\hardware\ADC\adc.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..
                    -\hardware\DELAY;..\hardware\ADC;..\hardware\Flash;..\hardware\Uart;..\hardware\Key;..\hardware\Pwm;..\hardware\WDT;..\ha
                    -rdware\Timer;..\hardware\LCDdisplay;..\hardware\PID) DEBUG OBJECTEXTEND PRINT(.\Listings\adc.lst) TABS(2) OBJECT(.\Objec
                    -ts\adc.obj)

line level    source

   1          #include "adc.h"
   2          #include "delay.h"
   3          #include "flash.h"
   4          
   5          void adc_init ( void )
   6          {
   7   1        P0M3 = 0x01;    //P03设置为模拟输入
   8   1        P0M7 = 0x01;        //P07设置为模拟输入
   9   1        P0M2 = 0x01;        //P02设置为模拟输入
  10   1        P2M1 = 0X01;        //P21设置为模拟输入
  11   1        ADCC0 = 0x81;   //打开ADC转换电源      4V为内部参考电压
  12   1        
  13   1        //00 VDD
  14   1      //                      01 内部4V
  15   1      //                      10 内部3V
  16   1      //                      11 内部2V
  17   1      //1、 内部参考电压选择为 2V 时， VDD 电压须高于 2.7V；
  18   1      //    内部参考电压选择为 3V 时， VDD 电压须高于 3.5V；
  19   1      //    内部参考电压选择为 4V 时， VDD 电压须高于4.5V。
  20   1      //2、 系统进入掉电模式前，建议将 ADC 参考电压选择非 VDD，可以进一步降低系统功耗。
  21   1        delay_us ( 80 );            //延时20us，确保ADC系统稳定
  22   1      
  23   1      //  ADCC1 = 0x08;           //选择ADC通道8
  24   1        ADCC2 = 0x49;;            //转换结果12位数据，数据右对齐，ADC时钟4分频 4M/4 = 1MHz
  25   1      }
  26          
  27          u16 get_adc_val_P07 ( void )
  28          {
  29   1        u16 adc_val = 0;
  30   1        ADCC1 = 0x07;           //选择ADC通道7
  31   1        ADCC0 |= 0x40;          //启动ADC转换
  32   1        while ( ! ( ADCC0&0x20 ) );     //等待ADC转换结束
  33   1        ADCC0 &=~ 0x20;         //清除标志位
  34   1        adc_val = ADCR;         //获取ADC的值
  35   1      //  ADCR = 0;
  36   1        return adc_val;
  37   1      }
  38          
  39          u16 get_adc_val_P03 ( void )
  40          {
  41   1        u16 adc_val = 0;
  42   1        ADCC1 = 0x03;           //选择ADC通道3
  43   1        ADCC0 |= 0x40;          //启动ADC转换
  44   1        while ( ! ( ADCC0&0x20 ) );     //等待ADC转换结束
  45   1        ADCC0 &=~ 0x20;         //清除标志位
  46   1        adc_val = ADCR;         //获取ADC的值
  47   1      //  ADCR = 0;
  48   1        return adc_val;
  49   1      }
  50          
  51          u16 get_adc_val_P02 ( void )
  52          {
C51 COMPILER V9.56.0.0   ADC                                                               09/23/2020 14:29:51 PAGE 2   

  53   1        u16 adc_val = 0;
  54   1        ADCC1 = 0x02;           //选择ADC通道2
  55   1        ADCC0 |= 0x40;          //启动ADC转换
  56   1        while ( ! ( ADCC0&0x20 ) );     //等待ADC转换结束
  57   1        ADCC0 &=~ 0x20;         //清除标志位
  58   1        adc_val = ADCR;         //获取ADC的值
  59   1      //  ADCR = 0;
  60   1        return adc_val;
  61   1      }
  62          
  63          u16 get_adc_val_P21 ( void )
  64          {
  65   1        u16 adc_val = 0;
  66   1        ADCC1 = 0x09;           //选择ADC通道2
  67   1        ADCC0 |= 0x40;          //启动ADC转换
  68   1        while ( ! ( ADCC0&0x20 ) );     //等待ADC转换结束
  69   1        ADCC0 &=~ 0x20;         //清除标志位
  70   1        adc_val = ADCR;         //获取ADC的值
  71   1      //  ADCR = 0;
  72   1        return adc_val;
  73   1      }
  74          
  75          
  76          
  77          
  78          void get_voltage ( u16* u1_voltage,u16* u3_voltage )
  79          {
  80   1        u32 temp = 0;
  81   1        u8  i = 0;
  82   1        
  83   1        for ( i=0; i<5; i++ )
  84   1        {
  85   2          temp+=get_adc_val_P03();
  86   2        }
  87   1        temp/=5;
  88   1        *u1_voltage = temp*4000/4095;
  89   1        
  90   1        delay_us ( 20 );
  91   1        temp = 0;
  92   1        for ( i=0; i<5; i++ )
  93   1        {
  94   2          temp+=get_adc_val_P07();
  95   2        }
  96   1        temp/=5;
  97   1        *u3_voltage = temp*4000/4095;
  98   1        
  99   1      }
 100          
 101          u16 Detection_Input_Voltage(void)
 102          {
 103   1         
 104   1        u32 tep = 0;
 105   1        u8 i = 0;
 106   1      
 107   1        for ( i = 0; i < 5; i++ )
 108   1        {
 109   2          tep += get_adc_val_P02();
 110   2        }
 111   1        tep /= 5;
 112   1        tep = tep*4000/4096;  //放大1000倍 保存小数点后三位 4096
 113   1      
 114   1        return tep;
C51 COMPILER V9.56.0.0   ADC                                                               09/23/2020 14:29:51 PAGE 3   

 115   1      }
 116          
 117          u16 Detection_Heat_Cailibration(void)
 118          {
 119   1        u32 tep = 0;
 120   1        u8 i = 0;
 121   1      
 122   1        for ( i = 0; i < 5; i++ )
 123   1        {
 124   2          tep += get_adc_val_P21();
 125   2        }
 126   1        tep /= 5;
 127   1        tep = tep*4000/4096;  //放大1000倍 保存小数点后三位 4096
 128   1      
 129   1        return tep;
 130   1      
 131   1      }
 132          
 133          //u16 get_voltage_val ( void )
 134          //{
 135          //  u32 tep = 0;
 136          //  u8 i = 0;
 137          //
 138          //  for ( i = 0; i < 5; i++ )
 139          //  {
 140          //    tep += get_adc_val();
 141          //  }
 142          //  tep /= 5;
 143          //  tep = tep*4000/4096;  //放大1000倍 保存小数点后三位 4096
 144          //  return tep;
 145          //}
 146          
 147          
 148          
 149          
 150          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    722    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      21
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
